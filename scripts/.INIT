#!/usr/bin/env bash
# Include in your script with:
# [ -z $SHELL_SETTINGS_DIR ] && source $HOME/github/shell-settings/scripts/.INIT
# Adds default trap functions and helper scripts common global variables
# Also ensures that all scripts in scripts folder are available to other scripts here
# @TODO: Ensure that we also include the nodejs/mac/proxmox/etc. scripts where applicable

set -euo pipefail

SCRIPTS_DIR=`cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd`
SHELL_SETTINGS_DIR="$(readlink -f ${SCRIPTS_DIR}/..)"
SCRIPT_NAME=

.SCRIPT_DIR() {
  cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd
}

.SCRIPT_NAME() {
  if [ -z $SCRIPT_NAME ]; then
    SCRIPT_NAME="`basename "$0"`"
  fi

  echo "${SCRIPT_NAME}"
}

export PATH="$(.SCRIPT_DIR):$PATH"

trap __exit EXIT HUP INT TERM

__exit() {
  local code=$?

  # ensure we are not in a recursive trap
  trap - EXIT HUP INT TERM

  if [ $code -ne 0 ]; then
    echo "[$code] There was a failure" >&2
  fi

  exit $code
}

log() {
  local input="${@:-$(</dev/stdin)}"
  args=( )
  local log_empty=n
  local include_date=n

  # more complex flags seen here https://stackoverflow.com/a/2875513/679716
  while test $# != 0; do
    case $1 in
      -e|--empty) log_empty=y ;;
      -d|--date) include_date=y ;;
      *)  args+=( "$1" ) ;;
    esac
    shift
  done
  set +u
  set -- "${args[@]}"
  set -u

  if [ "$log_empty" = "y" ]; then
    echo ""
    return 0
  fi

  if [ "$include_date" = "y" ]; then
    printf "[$(date +"%Y-%m-%d_%H%M%S") - $(.SCRIPT_NAME)] $input\n"
    return 0
  fi

  .SCRIPT_NAME
  printf "[${SCRIPT_NAME}] ${input}\n"
}

.log() {
  set +u
  log ${@}
  set -u
}

# if non_local_bin_path mise; echo "mise is installed"; fi
non_local_bin_path() {
  # remove shell-settings/script paths from PATH since we care if we have the actual binary available"
  local PATH=`echo $PATH | tr ":" "\n" | sort | uniq | grep -v "shell-settings/script" | tr "\n" ":" | sed 's/.$//'`

  if command -v "$1" > /dev/null 2>&1; then
    export NON_LOCAL_BIN_PATH=$PATH
    return 0
  else
    return 1
  fi
}

.non_local_bin_path() {
  non_local_bin_path "${@}"
}

.ismac() {
  if [ $os = "Darwin" ]; then
    return 0
  fi
  return 1
}

.findup() {
  local type="${1}"
  local needle="${2}"
  local _DIR="${PWD}"

  if [ "${type}" = "-d" ]; then
    while [[ $PWD != '/' && ${PWD##*/} != 'httpdocs' ]]; do
      if [ -d "$needle" ]; then
        echo "${PWD}/${needle}"
        builtin cd "${_DIR}"
        return 0
      fi

      builtin cd ..
    done
  else
    while [[ $PWD != '/' && ${PWD##*/} != 'httpdocs' ]]; do
      if [[ -d "$needle" || -f "$needle" || -h "$needle" ]]; then
        echo "${PWD}/${needle}"
        builtin cd "${_DIR}"
        return 0
      fi

      builtin cd ..
    done
  fi

  builtin cd "${_DIR}"
}

.gitdir() {
  .findup -d ".git"
}

# Example usage:
# some_long_running_command &
# .wait-for-pid $! 30 1200 "[%elapsed%] Waiting for ${repo_files} to finish generating"
.wait-for-pid() {
    local pid=$1          # Process ID to monitor
    local interval=$2     # Interval in seconds between checks (30)
    local timeout=$3      # Maximum time to wait in seconds (1200 = 20 minutes)
    local message=$4      # Message template to display
    local start_time=$(date +%s)
    local elapsed=0

    while kill -0 "$pid" 2>/dev/null; do
        # Calculate elapsed time
        current_time=$(date +%s)
        elapsed=$((current_time - start_time))

        # Check if we've exceeded timeout
        if [ $elapsed -ge $timeout ]; then
            echo "Process timed out after ${timeout} seconds. Killing PID ${pid}"
            kill -9 "$pid"
            return 1
        fi

        # Display status message with elapsed time
        status_msg=$(echo "[$pid] $message" | sed "s/\[%elapsed%\]/$elapsed/")
        echo "$status_msg"

        # Wait for specified interval
        sleep "$interval"
    done

    return 0
}

.log init
