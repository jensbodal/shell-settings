{
  "content": [
    {
      "type": "text",
      "text": "TITLE: Handle Chat Message Processing and Streaming\nDESCRIPTION: This asynchronous block manages the lifecycle of a chat message, from initial user input to displaying the streamed AI response. It integrates RAG for user messages, fetches chat completions, handles streaming updates, renders markdown, and manages UI state (loading, success, failure, abortion).\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/playground.html#_snippet_23\n\nLANGUAGE: JavaScript\nCODE:\n```\n(message.role === \"user\" && typeof message.content === \"string\") { message.content = await this.searchRag(this.settings.rag, message.content); } } const stream = await fetchChatCompletions(CHAT_COMPLETIONS_URL, body, this.askAbortController.signal) for await (const chunk of stream) { lastMessage.state = \"streaming\"; lastMessage.content += chunk?.choices[0]?.delta?.content || \"\"; lastMessage.html = renderMarkdown(lastMessage.content, lastMessage.error); this.$nextTick(() => { this.autoScrollChatBodyToBottom(); }); } lastMessage.state = \"succeed\"; succeed = true; } catch (err) { lastMessage.state = \"failed\"; if (this.askAbortController?.signal?.aborted) { lastMessage.error = \"Error: Aborted\"; } else { lastMessage.error = err?.message || err; } lastMessage.html = renderMarkdown(lastMessage.content, lastMessage.error); } if (succeed) { this.sessionMode = true; } this.asking = false; },\n```\n\n----------------------------------------\n\nTITLE: Fetch and Stream Chat Completions from API in JavaScript\nDESCRIPTION: Sends a POST request to a chat completions API endpoint. It supports both streaming and non-streaming responses. For streaming, it reads the response body in chunks, decodes them, handles partial lines, and yields parsed JSON objects. It also manages abortion signals and throws errors for non-OK responses.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/arena.html#_snippet_24\n\nLANGUAGE: JavaScript\nCODE:\n```\nasync function* fetchChatCompletions(url, body, signal) {\n  const stream = body.stream;\n  const response = await fetch(url, {\n    method: \"POST\",\n    signal,\n    headers: getHeaders(),\n    body: JSON.stringify(body),\n  });\n  if (!response.ok) {\n    const error = await response.json();\n    throw error?.error || error;\n  }\n  if (!stream) {\n    const data = await response.json();\n    return data;\n  }\n  const reader = response.body.getReader();\n  const decoder = new TextDecoder();\n  let done = false;\n  let reamingChunkValue = \"\";\n  while (!done) {\n    if (signal?.aborted) {\n      reader.cancel();\n      break;\n    }\n    const { value, done: doneReading } = await reader.read();\n    done = doneReading;\n    const chunkValue = decoder.decode(value);\n    const lines = (reamingChunkValue + chunkValue).split(\"\\n\").filter(line => line.trim().length > 0);\n    reamingChunkValue = \"\";\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      const message = line.replace(/^data: /, \"\");\n      if (message === \"[DONE]\") {\n        continue\n      }\n      try {\n        const parsed = JSON.parse(message);\n        yield parsed;\n      } catch {\n        if (i === lines.length - 1) {\n          reamingChunkValue += line;\n          break;\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Fetch Chat Completions with Streaming\nDESCRIPTION: This asynchronous generator function handles fetching chat completions, supporting both streaming and non-streaming responses. It sends a POST request with a JSON body, manages abort signals, and parses Server-Sent Events (SSE) for streaming, yielding each parsed chunk. It also includes error handling for network issues or API errors.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/playground.html#_snippet_27\n\nLANGUAGE: JavaScript\nCODE:\n```\nasync function* fetchChatCompletions(url, body, signal) { const stream = body.stream; const response = await fetch(url, { method: \"POST\", signal, headers: getHeaders(), body: JSON.stringify(body), }); if (!response.ok) { const error = await response.json(); throw error?.error || error; } if (!stream) { const data = await response.json(); return data; } const reader = response.body.getReader(); const decoder = new TextDecoder(); let done = false; let reamingChunkValue = \"\"; while (!done) { if (signal?.aborted) { reader.cancel(); break; } const { value, done: doneReading } = await reader.read(); done = doneReading; const chunkValue = decoder.decode(value); const lines = (reamingChunkValue + chunkValue).split(\"\\n\").filter(line => line.trim().length > 0); reamingChunkValue = \"\"; for (let i = 0; i < lines.length; i++) { const line = lines[i]; const message = line.replace(/^data: /, \"\"); if (message === \"[DONE]\") { continue } try { const parsed = JSON.parse(message); yield parsed; } catch { if (i === lines.length - 1) { reamingChunkValue += line; break; } } } } }\n```\n\n----------------------------------------\n\nTITLE: Send Chat Completion Request and Stream Response in JavaScript\nDESCRIPTION: Initiates a chat completion request to an AI model, handling streaming responses. It manages the chat state, updates the last message content incrementally, renders markdown, and handles errors and abortion signals. It also ensures the chat body scrolls to the bottom as new content arrives.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/arena.html#_snippet_21\n\nLANGUAGE: JavaScript\nCODE:\n```\nasync ask(index) {\n  const chat = this.chats[index];\n  chat.askAbortController = new AbortController();\n  chat.shouldScrollChatBodyToBottom = true;\n  this.$nextTick(() => {\n    this.autoScrollChatBodyToBottom(index);\n  });\n  const lastMessage = chat.messages[chat.messages.length - 1];\n  const body = this.buildBody(index);\n  let succeed = false;\n  try {\n    const stream = await fetchChatCompletions(CHAT_COMPLETIONS_URL, body, chat.askAbortController.signal)\n    for await (const chunk of stream) {\n      lastMessage.state = \"streaming\";\n      lastMessage.content += chunk?.choices[0]?.delta?.content || \"\";\n      lastMessage.html = renderMarkdown(lastMessage.content, lastMessage.error);\n      this.$nextTick(() => {\n        this.autoScrollChatBodyToBottom(index);\n      });\n    }\n    lastMessage.state = \"succeed\";\n    succeed = true;\n  } catch (err) {\n    lastMessage.state = \"failed\";\n    if (this.askAbortController?.signal?.aborted) {\n      lastMessage.error = \"\";\n    } else {\n      lastMessage.error = err?.message || err;\n    }\n    lastMessage.html = renderMarkdown(lastMessage.content, lastMessage.error);\n  }\n  this.asking--;\n}\n```\n\n----------------------------------------\n\nTITLE: Install AIChat using Package Managers\nDESCRIPTION: Instructions for installing AIChat using various package managers like Cargo (for Rust developers), Homebrew/Linuxbrew, Pacman, Windows Scoop, and Android Termux's pkg.\nSOURCE: https://github.com/sigoden/aichat/blob/main/README.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\ncargo install aichat\n```\n\nLANGUAGE: Shell\nCODE:\n```\nbrew install aichat\n```\n\nLANGUAGE: Shell\nCODE:\n```\npacman -S aichat\n```\n\nLANGUAGE: Shell\nCODE:\n```\nscoop install aichat\n```\n\nLANGUAGE: Shell\nCODE:\n```\npkg install aichat\n```\n\n----------------------------------------\n\nTITLE: Escape HTML Special Characters\nDESCRIPTION: Escapes common HTML special characters (&, <, >, \", ') in a string to prevent cross-site scripting (XSS) vulnerabilities when rendering user-provided content directly into HTML.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/playground.html#_snippet_37\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction escapeForHTML(input) { const escapeMap = { \"&\": \"&amp;\", \"<\": \"&lt;\", \">\": \"&gt;\", \"\\\"\": \"&quot;\", \"'\": \"&#39;\" }; return input.replace(/([&<>\"'])/g, char => escapeMap[char]); }\n```\n\n----------------------------------------\n\nTITLE: Escape Special Characters for HTML (JavaScript)\nDESCRIPTION: Escapes common HTML special characters (`&`, `<`, `>`, `\"`, `'`) in a string to their corresponding HTML entities. This prevents cross-site scripting (XSS) vulnerabilities and ensures text is rendered correctly in HTML contexts.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/arena.html#_snippet_32\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction escapeForHTML(input) { const escapeMap = { \"&\": \"&amp;\", \"<\": \"&lt;\", \">\": \"&gt;\", \"\\\"\": \"&quot;\", \"'\": \"&#39;\" }; return input.replace(/([&<>\"'])/g, char => escapeMap[char]); }\n```\n\n----------------------------------------\n\nTITLE: Global CSS Styles and UI Component Layout for AIChat LLM Arena\nDESCRIPTION: This extensive CSS block defines the foundational styling for the AIChat LLM Arena application. It sets up global CSS variables for colors and fonts, establishes the overall page layout, and styles individual UI components such as chat panels, message displays, input areas, and interactive buttons. It also includes media queries for responsive design and a dark mode theme.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/arena.html#_snippet_0\n\nLANGUAGE: css\nCODE:\n```\n:root { --fg-primary: #1652f1; --fg-default: black; --bg-primary: white; --bg-default: #f9f9f9; --bg-toast: rgba(0, 0, 0, 0.7); --border-color: #c3c3c3; }\n[x-cloak] { display: none !important; }\nhtml { font-family: Noto Sans, SF Pro SC, SF Pro Text, SF Pro Icons, PingFang SC, Helvetica Neue, Helvetica, Arial, sans-serif }\nbody, div { padding: 0; margin: 0; box-sizing: border-box; }\ntextarea, input, select, option { color: var(--fg-default); background-color: var(--bg-primary); }\nbody { font-family: Arial, sans-serif; font-size: 1rem; display: flex; height: 100vh; color: var(--fg-default); background-color: var(--bg-default); }\n.container { display: flex; flex-direction: column; background-color: var(--bg-primary); width: 100%; }\n.chats { display: flex; flex-direction: row; flex-grow: 1; width: 100%; }\n.chat-panel { display: flex; flex-direction: column; width: 100%; }\n.chat-header { display: flex; padding: 0.5rem; flex-direction: row; border-bottom: 1px solid var(--border-color); }\n.chat-header select { width: 100%; outline: none; font-size: 1.25rem; border: none; }\n.chat-body { display: flex; flex-direction: column; flex-grow: 1; overflow-x: hidden; overflow-y: auto; }\n.chat-message { display: flex; padding: 0.7rem; margin-bottom: 0.7rem; }\n.chat-avatar svg { width: 1.25rem; height: 1.25rem; border-radius: 50%; }\n.chat-message-content { position: relative; display: flex; flex-direction: column; width: calc(100% - 1rem); margin-top: -2px; padding-left: 0.625rem; flex-grow: 1; }\n.chat-message-content .error { color: red; background: none; padding: 0; }\n.chat-message-content .message-text { white-space: pre-wrap; padding-top: 0.2rem; }\n.message-image-bar { display: flex; flex-direction: row; overflow-x: auto; }\n.message-image { margin: 0.25rem; }\n.message-image img { width: 10rem; height: 10rem; object-fit: cover; }\n.markdown-body { display: flex; width: 100%; padding: 0; flex-direction: column; background-color: var(--bg-primary); }\n.markdown-body:first-child { margin-top: 0; padding-top: 0; }\n.markdown-body pre { overflow-x: auto; word-wrap: break-word; }\n.code-block { position: relative; width: 100%; }\n.message-toolbox { display: flex; position: absolute; bottom: -1.4rem; }\n.copy-message-btn, .regenerate-message-btn, .tts-message-btn { top: 0.7rem; right: 0.7rem; cursor: pointer; font-size: 0.9rem; padding-right: 4px; }\n.copy-message-btn svg, .regenerate-message-btn svg, .tts-message-btn svg { width: 1rem; height: 1rem; }\n.copy-code-btn { position: absolute; top: 0.7rem; right: 0.7rem; cursor: pointer; font-size: 0.9rem; }\n.copy-code-btn svg { width: 1rem; height: 1rem; }\n.scroll-to-bottom-btn { position: absolute; text-align: center; cursor: pointer; width: 1.5rem; height: 1.5rem; border-radius: 0.75rem; background-color: var(--bg-primary); }\n.scroll-to-bottom-btn svg { width: 1.5rem; height: 1.5rem; border-radius: 50%; }\n.input-panel { position: relative; border-top: 1px solid var(--border-color); }\n.input-panel-inner { margin: 1rem; padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 1rem; }\n.input-panel-inner textarea { width: 100%; font-size: 1rem; padding: 0.4rem; box-sizing: border-box; border: none; outline: none; resize: none; max-height: 500px; overflow-x: hidden; overflow-y: auto; }\n.input-toolbox { position: absolute; display: flex; right: 1.875rem; font-size: 1rem; bottom: 1.875rem; cursor: pointer; }\n.input-toolbox svg { width: 1.875rem; height: 1.875rem; fill: var(--fg-default); }\n.image-btn { position: relative; display: inline-block; margin-right: 0.5rem; }\n.image-btn input[type=\"file\"] { position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; }\n.input-image-bar { display: flex; flex-direction: row; width: 100%; overflow-x: auto; }\n.input-image-item { display: flex; margin: 0.25rem; width: 5rem; position: relative; }\n.input-image-item img { width: 5rem; height: 5rem; object-fit: cover; }\n.image-remove-btn { font-size: 1rem; margin-left: -0.8rem; cursor: pointer; }\n.image-remove-btn { width: 1rem; height: 1rem; }\n.input-btn.disabled { opacity: 0.3; }\n.spinner { width: 1.1rem; height: 1.1rem; margin-top: 3px; border: 2px solid var(--fg-default); border-bottom-color: transparent; border-radius: 50%; display: inline-block; animation: spinner-rotation 1s linear infinite; }\n.toast { display: none; position: fixed; top: 2px; left: 50%; text-align: center; transform: translate(-50%, 0); background-color: var(--bg-toast); color: var(--bg-primary); padding: 0.5rem; border-radius: 0.3rem; z-index: 9999; }\n@keyframes spinner-rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }\n@media (prefers-color-scheme: dark) { :root { --fg-primary: #1652f1; --fg-default: white; --bg-primary: black; --bg-default: #121212; --bg-toast: rgba(255, 255, 255, 0.7); --border-color: #3c3c3c; } }\n@media screen and (max-width: 768px) { body { height: calc(100vh - 56px); height: 100dvh; }\n.container { padding: 3px; }\n```\n\n----------------------------------------\n\nTITLE: Update URL Search Parameters\nDESCRIPTION: This function dynamically updates the browser's URL search parameters based on specific settings. It iterates over a predefined list of keys ('model', 'rag', 'role', etc.) from `this.settings`. If a setting has a value, it's added to the URL; otherwise, it's removed. The browser history is updated without a full page reload.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/playground.html#_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\nupdateUrl() { const newUrl = new URL(location.href); [\"model\", \"rag\", \"role\", \"max_output_tokens\", \"temperature\", \"top_p\"].forEach(key => { if (this.settings[key] || typeof this.settings[key] === \"number\") { newUrl.searchParams.set(key, this.settings[key]); } else { newUrl.searchParams.delete(key); } }); history.replaceState(null, '', newUrl.toString()); }\n```\n\n----------------------------------------\n\nTITLE: Alpine.js Application Data and Initialization Logic\nDESCRIPTION: This code defines the `setupApp` function and the Alpine.js `app` data object. It initializes default settings, fetches models, RAGs, and roles from APIs, and sets up watchers for input, settings, and model/role changes. It also includes a keydown event listener for global shortcuts.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/playground.html#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction setupApp() { let msgIdx = 0; let defaultSettings = { model: QUERY.model || \"default\", rag: QUERY.rag || \"\", role: QUERY.role || \"\", prompt: \"\", max_output_tokens: parseInt(QUERY.max_output_tokens) || null, temperature: QUERY.temperature ? parseFloat(QUERY.temperature) : null, top_p: QUERY.top_p ? parseFloat(QUERY.top_p) : null, }; Alpine.data(\"app\", () => ({ models: [], rags: [\"\"], roles: [{ name: \"\", prompt: \"\" }], settings: defaultSettings, modelData: {}, messages: [], input: \"\", images: [], asking: false, askAbortController: null, hoveredMessageIndex: null, shouldScrollChatBodyToBottom: true, isShowScrollToBottomBtn: false, showModal: \"\", sessionMode: false, sessionTitle: \"\", selectSessionId: null, sessions: [], async init() { await Promise.all([ fetchJSON(MODELS_API).then(models => { this.models = models.filter(v => !v.type || v.type === \"chat\"); }).catch(err => { toast(\"No model available\"); console.error(\"Failed to load models\", err); }), fetchJSON(RAGS_API).then(rags => { this.rags.push(...rags); }).catch(() => { }), fetchJSON(ROLES_API).then(roles => { this.roles.push(...roles.filter(v => !!v.prompt)); }).catch(() => { }), ]) this.$refs.input.addEventListener(\"paste\", (e) => this.handlePaste(e)); this.$watch(\"input\", () => this.autosizeInput(this.$refs.input)); this.$watch(\"settings\", () => this.updateUrl()); this.$watch(\"settings.model\", () => this.handleModelChange()); if (this.models.find(model => model.id === this.settings.model)) { this.handleModelChange(); } else { this.settings.model = \"default\"; } if (!this.rags.find(rag => rag === this.settings.rag)) { this.settings.rag = \"\"; } this.$watch(\"settings.role\", () => this.handleRoleChange()) if (this.roles.find(role => role.name === this.settings.role)) { this.handleRoleChange(); } else { this.settings.role = \"\"; } document.addEventListener(\"keydown\", (event) => this.handleKeyDown(event)) },\n```\n\n----------------------------------------\n\nTITLE: Start New Chat Session\nDESCRIPTION: This function initiates a new chat session. If an existing session is active and has a title, it saves the current session's state (settings, messages, mode, title) to the `sessions` array. It then resets all chat-related state variables, including clearing messages, setting `asking` to false, and focusing the input field.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/playground.html#_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nhandleNewChat() { if (this.asking) { this.askAbortController?.abort(); } if (this.sessionTitle) { const lastMessage = this.messages[this.messages.length - 1]; if (lastMessage.state === \"loading\") { lastMessage.state = \"failed\"; lastMessage.error = \"Error: Aborted\"; lastMessage.html = renderMarkdown(lastMessage.content, lastMessage.error); } const sessionData = JSON.parse(JSON.stringify({ settings: this.settings, messages: this.messages, sessionMode: this.sessionMode, sessionTitle: this.sessionTitle })); let session = this.sessions.find(v => v.id === this.selectSessionId); if (session) { Object.assign(session, sessionData); } else { this.sessions.unshift({ id: randomUUID(), createdAt: Date.now(), ...sessionData }); } } this.messages = []; this.asking = false; this.askAbortController = null; this.hoveredMessageIndex = null; this.shouldScrollChatBodyToBottom = true; this.isShowScrollToBottomBtn = false; this.showModal = \"\"; this.sessionMode = false; this.sessionTitle = \"\"; this.selectSessionId = null; this.focusInput(); }\n```\n\n----------------------------------------\n\nTITLE: Implement Asynchronous Sleep in JavaScript\nDESCRIPTION: This snippet shows how to create an asynchronous delay function in JavaScript. It uses a Promise that resolves after a specified number of milliseconds, effectively pausing execution without blocking the main thread. Useful for controlling timing in async operations.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/roles/%code%.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nasync function timeout(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n```\n\n----------------------------------------\n\nTITLE: Configure Marked.js for Markdown Rendering\nDESCRIPTION: Sets up the Marked.js library with custom renderers and extensions for enhanced markdown processing. It includes a custom code block renderer with syntax highlighting, a 'think' block extension for displaying hidden thoughts, and support for KaTeX for mathematical expressions.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/playground.html#_snippet_36\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction setupMarked() { const renderer = { code({ text, lang }) { const validLang = !!(lang && hljs.getLanguage(lang)); const highlighted = validLang ? hljs.highlight(text, { language: lang }).value : escapeForHTML(text); return `<div class=\"code-block\"> <pre><code class=\"hljs ${lang}\">${highlighted}</code></pre> <div class=\"copy-code-btn\" @click=\"handleCopyCode\" title=\"Copy code\"> <svg fill=\"currentColor\" viewBox=\"0 0 16 16\"> <path fill-rule=\"evenodd\" d=\"M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1zM2 5a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h1v1a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1v1z\"/> </svg> </div> </div>`; } }; const thinkExtension = { name: 'think', level: 'block', start(src) { const match = /^(\\s*)<think>/.exec(src); if (match) { return match[1].length } else { return -1; } }, tokenizer(src, tokens) { const rule = /^\\s*<think>([\\s\\S]*?)(<\\/think>|$)/; const match = rule.exec(src); if (match) { return { type: 'think', raw: match[0], text: match[1].trim(), }; } }, renderer(token) { const text = '<p>' + token.text.trim().replace(/\\n+/g, '</p><p>') + '</p>'; return `<details open class=\"think\"> <summary>Deeply thought</summary> <blockquote>${text}</blockquote> </details>`; }, }; marked.use({ renderer }); marked.use(markedKatex({ throwOnError: false, inlineTolerantNoSpace: true })); marked.use({ extensions: [thinkExtension] }) }\n```\n\n----------------------------------------\n\nTITLE: CSS Styles for AIChat User Interface\nDESCRIPTION: This CSS defines the visual appearance and layout for key components of the AIChat application. It includes styles for interactive elements such as file input buttons, image display, session list items, modal dialogs, loading spinners, and transient toast messages. Media queries are used to provide responsive design for smaller screens and to support dark mode preferences.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/playground.html#_snippet_0\n\nLANGUAGE: CSS\nCODE:\n```\ny: inline-block; margin-right: 0.5rem; } .image-btn input[type=\"file\"] { position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; } .input-image-bar { display: flex; flex-direction: row; width: 100%; overflow-x: auto; } .input-image-item { display: flex; margin: 0.25rem; width: 5rem; position: relative; } .input-image-item img { width: 5rem; height: 5rem; object-fit: cover; } .image-remove-btn { font-size: 1rem; margin-left: -0.8rem; cursor: pointer; } .image-remove-btn { width: 1rem; height: 1rem; } .input-btn.disabled { opacity: 0.3; } .session-list { padding-top: 0.4rem; max-height: 80vh; font-size: 0.8rem; overflow-y: auto; overflow-x: hidden; } .session-item { padding: 5px; border-bottom: 1px solid var(--border-color); cursor: pointer; } .session-item:hover { background-color: var(--bg-hover); } .session-title { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--bg-cover); z-index: 1000; display: flex; align-items: flex-start; justify-content: center; padding-top: 50px; } .modal-content { position: relative; padding: 0.8rem; border-radius: 8px; max-width: 1000px; width: calc(100% - 100px); background-color: var(--bg-primary); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); } .modal-header { display: flex; flex-direction: row; align-items: center; } .modal-header .title { font-weight: 500; font-size: 1.5rem; } .modal-header .close-btn { margin-left: auto; color: var(--fg-default); background: none; border: none; font-size: 24px; cursor: pointer; } .spinner { width: 1.1rem; height: 1.1rem; margin-top: 3px; border: 2px solid var(--fg-default); border-bottom-color: transparent; border-radius: 50%; display: inline-block; animation: spinner-rotation 1s linear infinite; } .toast { display: none; position: fixed; bottom: 1rem; left: 1rem; text-align: center; background-color: var(--bg-toast); color: var(--bg-primary); padding: 0.5rem; border-radius: 0.3rem; z-index: 9999; } @keyframes spinner-rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } @media (prefers-color-scheme: dark) { :root { --fg-primary: #1652f1; --fg-default: white; --bg-primary: black; --bg-default: #121212; --bg-toast: rgba(255, 255, 255, 0.7); --bg-cover: rgba(255, 255, 255, 0.5); --bg-hover: #1f1f1f; --border-color: #3c3c3c; --shadow-color: rgba(255, 255, 255, 0.1); } } @media screen and (max-width: 768px) { body { height: calc(100vh - 56px); height: 100dvh; } .container { padding: 3px; } .sidebar { display: none; width: 100%; height: 100%; margin-right: 0; } .main-panel { width: 100%; } .chat-header { padding: 0.6rem; } .chat-header select { font-size: 1rem; } .chat-body { padding: 0.6rem; } .input-panel-inner { margin: 0.5rem; } .scroll-to-bottom-btn { right: 50%; } .hide-sidebar-btn { display: block; } .show-sidebar-btn { display: block; } }\n```\n\n----------------------------------------\n\nTITLE: Fetch JSON Data with Custom Headers in JavaScript\nDESCRIPTION: Asynchronously fetches JSON data from a specified URL. It applies custom headers obtained from the `getHeaders()` function to the request. Upon successful response, it parses the JSON and returns the `data` property from the parsed object.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/arena.html#_snippet_23\n\nLANGUAGE: JavaScript\nCODE:\n```\nasync function fetchJSON(url) {\n  const res = await fetch(url, { headers: getHeaders() });\n  const data = await res.json()\n  return data.data;\n}\n```\n\n----------------------------------------\n\nTITLE: Handle Global Keyboard Shortcuts\nDESCRIPTION: This function listens for global keyboard events to trigger specific actions. It supports 'Ctrl+Shift+O' (or 'Cmd+Shift+O' on Mac) for a new chat, 'Ctrl+Shift+L' (or 'Cmd+Shift+L' on Mac) to show a list of sessions, 'Shift+Escape' to focus the input, and 'Escape' to close any active modal.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/playground.html#_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\nhandleKeyDown(event) { const isMac = navigator.platform.toUpperCase().indexOf('MAC') > -1; const controlKey = isMac ? event.metaKey : event.ctrlKey; if (controlKey && event.shiftKey && event.key.toLowerCase() === 'o') { event.preventDefault(); this.handleNewChat(); } else if (controlKey && event.shiftKey && event.key.toLowerCase() === 'l') { event.preventDefault(); this.showModal = 'list-sessions' } else if (event.shiftKey && event.key === \"Escape\") { event.preventDefault(); this.focusInput(); } else if (this.showModal && event.key === \"Escape\") { event.preventDefault(); this.showModal = \"\"; } }\n```\n\n----------------------------------------\n\nTITLE: Test AIChat Chat Completions API with cURL\nDESCRIPTION: This cURL command demonstrates how to interact with the local AIChat Chat Completions API endpoint. It sends a POST request with a JSON payload to request a chat completion from a specified model, enabling streaming responses.\nSOURCE: https://github.com/sigoden/aichat/blob/main/README.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ncurl -X POST -H \"Content-Type: application/json\" -d '{\n  \"model\":\"claude:claude-3-5-sonnet-20240620\",\n  \"messages\":[{\"role\":\"user\",\"content\":\"hello\"}], \n  \"stream\":true\n}' http://127.0.0.1:8000/v1/chat/completions\n```\n\n----------------------------------------\n\nTITLE: Alpine.js App Data and Initialization Logic\nDESCRIPTION: Defines the core Alpine.js `app` data object, including state variables for chat models, user input, images, and an array of chat instances. The `init` method fetches available models, configures chat panel widths based on the number of chats, and sets up event listeners for input pasting and resizing.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/arena.html#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction setupApp() {\n  let $inputPanel = document.querySelector('.input-panel');\n  let $chatPanels = [];\n  let $scrollToBottomBtns = [];\n  let msgIdx = 0;\n  Alpine.data(\"app\", () => ({\n    chatModels: [],\n    input: \"\",\n    images: [],\n    asking: 0,\n    chats: Array.from(Array(NUM)).map(_ => ({\n      model: \"\",\n      messages: [],\n      hoveredMessageIndex: null,\n      askAbortController: null,\n      shouldScrollChatBodyToBottom: true,\n      isShowScrollToBottomBtn: false,\n    })),\n    async init() {\n      try {\n        const models = await fetchJSON(MODELS_API);\n        this.chatModels = models.filter(v => !v.type || v.type === \"chat\");\n      } catch (err) {\n        toast(\"No available model\");\n        console.error(\"Failed to load models\", err);\n      }\n      let models = []\n      if (QUERY.models) {\n        models = QUERY.models.split(\",\");\n      }\n      $chatPanels = document.querySelectorAll('.chat-panel');\n      $scrollToBottomBtns = document.querySelectorAll('.scroll-to-bottom-btn');\n      const offsets = calculateOffsets(NUM);\n      for (let i = 0; i < NUM; i++) {\n        this.chats[i].model = models[i] || \"default\";\n        $chatPanels[i].style.width = (100 / NUM) + '%';\n        if (i > 0) {\n          $chatPanels[i].style.borderLeft = '1px solid var(--border-color)';\n        }\n        $scrollToBottomBtns[i].style.left = offsets[i];\n      }\n      this.$refs.input.addEventListener(\"paste\", (e) => this.handlePaste(e));\n      this.$watch(\"input\", () => this.autosizeInput(this.$refs.input));\n      new ResizeObserver(() => {\n        this.autoHeightChatPanel();\n      }).observe($inputPanel)\n    }\n```\n\n----------------------------------------\n\nTITLE: Alpine.js `handleAsk` Method for Sending Messages\nDESCRIPTION: Handles the submission of user messages. It constructs message objects, including text and image parts if images are present, and pushes them to each chat instance's message array. It then initiates the `ask` process for all active chats and clears the input fields.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/arena.html#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nhandleAsk() {\n  const isEmptyInput = this.input.trim() === \"\";\n  const isEmptyImage = this.images.length === 0;\n  if (this.asking > 0 || (isEmptyImage && isEmptyInput)) {\n    return;\n  }\n  for (let index = 0; index < this.chats.length; index++) {\n    const chat = this.chats[index];\n    if (isEmptyImage) {\n      chat.messages.push({ id: msgIdx++, role: \"user\", content: this.input, });\n    } else {\n      const parts = [];\n      if (!isEmptyInput) {\n        parts.push({ type: \"text\", text: this.input });\n      }\n      for (const image of this.images) {\n        parts.push({ type: \"image_url\", image_url: { url: image } });\n      }\n      chat.messages.push({ id: msgIdx++, role: \"user\", content: parts, })\n    }\n    chat.messages.push({ id: msgIdx++, role: \"assistant\", content: \"\", state: \"loading\", // streaming, succeed, failed error: \"\", html: \"\", });\n  }\n  for (let index = 0; index < this.chats.length; index++) {\n    this.asking++;\n    this.ask(index);\n  }\n  this.input = \"\";\n  this.images = [];\n},\n```\n\n----------------------------------------\n\nTITLE: Initiate AI Chat Request\nDESCRIPTION: This asynchronous function initiates a request to the AI model. It sets up an `AbortController` for potential cancellation, ensures the chat body scrolls to the bottom, and prepares the request body. The function is cut off, but it typically proceeds to make an API call.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/playground.html#_snippet_22\n\nLANGUAGE: javascript\nCODE:\n```\nasync ask() { this.askAbortController = new AbortController(); this.shouldScrollChatBodyToBottom = true; this.$nextTick(() => { this.autoScrollChatBodyToBottom(); }); const lastMessage = this.messages[this.messages.length - 1]; const body = this.buildBody(); let succeed = false; try { if (this.settings.rag) { const message = body.messages[body.messages.length - 1]; if\n```\n\n----------------------------------------\n\nTITLE: Configure Marked.js for Custom Markdown Rendering (JavaScript)\nDESCRIPTION: Configures the `marked.js` library with a custom renderer for code blocks and a custom extension for a `<think>` tag. The code renderer adds syntax highlighting using `highlight.js` and a copy button. The `think` extension renders content within `<think>` tags into an expandable `<details>` block with a 'Deeply thought' summary.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/arena.html#_snippet_31\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction setupMarked() { const renderer = { code({ text, lang }) { const validLang = !!(lang && hljs.getLanguage(lang)); const highlighted = validLang ? hljs.highlight(text, { language: lang }).value : escapeForHTML(text); return \"<div class=\\\"code-block\\\">\\n <pre><code class=\\\"hljs ${lang}\\\">${highlighted}</code></pre>\\n <div class=\\\"copy-code-btn\\\" @click=\\\"handleCopyCode\\\" title=\\\"Copy code\\\">\\n <svg fill=\\\"currentColor\\\" viewBox=\\\"0 0 16 16\\\">\\n <path fill-rule=\\\"evenodd\\\" d=\\\"M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1zM2 5a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h1v1a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1v1z\\\"/>\\n </svg>\\n </div>\\n </div>\"; } }; const thinkExtension = { name: 'think', level: 'block', start(src) { const match = /^(\\s*)<think>/.exec(src); if (match) { return match[1].length } else { return -1; } }, tokenizer(src, tokens) { const rule = /^\\s*<think>([\\s\\S]*?)(<\\/think>|$)/; const match = rule.exec(src); if (match) { return { type: 'think', raw: match[0], text: match[1].trim(), }; } }, renderer(token) { const text = '<p>' + token.text.trim().replace(/\\n+/g, '</p><p>') + '</p>'; return \"<details open class=\\\"think\\\"> <summary>Deeply thought</summary> <blockquote>${text}</blockquote> </details>\"; }, }; marked.use({ renderer }); marked.use(markedKatex({ throwOnError: false, inlineTolerantNoSpace: true })); marked.use({ extensions: [thinkExtension] }) }\n```\n\n----------------------------------------\n\nTITLE: JavaScript Function to Handle User Ask/Submit\nDESCRIPTION: This function manages the user's submission of a new message, including text and images. It constructs the message object for the chat history, updates the session title if it's the first message, clears the input, and initiates the AI `ask` process.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/playground.html#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nhandleAsk() { const isEmptyInput = this.input.trim() === \"\"; const isEmptyImage = this.images.length === 0; if (this.asking || (isEmptyImage && isEmptyInput)) { return; } if (this.messages.length === 0) { let sessionTitle = \"\" if (this.images.length > 0) { sessionTitle = `🖼️x${this.images.length} ` } if (this.input) { sessionTitle += this.input.trim().replace(/\\n/g, \"↵\").slice(0, 200); } this.sessionTitle = sessionTitle; } if (isEmptyImage) { this.messages.push({ id: msgIdx++, role: \"user\", content: this.input, }); } else { const parts = []; if (!isEmptyInput) { parts.push({ type: \"text\", text: this.input }); } for (const image of this.images) { parts.push({ type: \"image_url\", image_url: { url: image } }); } this.messages.push({ id: msgIdx++, role: \"user\", content: parts, }) } this.messages.push({ id: msgIdx++, role: \"assistant\", content: \"\", state: \"loading\", // streaming, succeed, failed error: \"\", html: \"\", }); this.input = \"\"; this.images = []; this.asking = true; this.ask(); },\n```\n\n----------------------------------------\n\nTITLE: Fetch JSON Data\nDESCRIPTION: A utility asynchronous function to fetch data from a given URL. It sends a GET request with standard headers and parses the response as JSON, returning the `data` property from the JSON object.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/playground.html#_snippet_26\n\nLANGUAGE: JavaScript\nCODE:\n```\nasync function fetchJSON(url) { const res = await fetch(url, { headers: getHeaders() }); const data = await res.json() return data.data; }\n```\n\n----------------------------------------\n\nTITLE: Display Toast Notification\nDESCRIPTION: This function displays a temporary toast notification on the UI. It sets the text content of an element with ID 'toast', makes it visible, and automatically hides it after a specified duration (defaulting to 2500ms). It also clears any previous toast timers to prevent overlapping.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/playground.html#_snippet_30\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction toast(text, duration = 2500) { const $toast = document.getElementById(\"toast\"); clearTimeout($toast._timer); $toast.textContent = text; $toast.style.display = \"block\"; $toast._timer = setTimeout(function () { $toast.style.display = \"none\"; }, duration); }\n```\n\n----------------------------------------\n\nTITLE: JavaScript Function to Cancel AI Request\nDESCRIPTION: This function aborts any ongoing AI request by calling the `abort()` method on the `askAbortController`. This allows users to stop a long-running generation.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/playground.html#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\nhandleCancelAsk() { this.askAbortController?.abort(); },\n```\n\n----------------------------------------\n\nTITLE: Chunk Array into Smaller Arrays\nDESCRIPTION: Splits a given array into smaller arrays (chunks) of a specified size. This is useful for processing large arrays in batches or for pagination purposes.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/playground.html#_snippet_39\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction chunkArray(array, chunkSize) { const chunks = []; for (let i = 0; i < array.length; i += chunkSize) { chunks.push(array.slice(i, i + chunkSize)); } return chunks; }\n```\n\n----------------------------------------\n\nTITLE: Chunk Array into Smaller Arrays (JavaScript)\nDESCRIPTION: Splits a given array into smaller arrays (chunks) of a specified size. It iterates through the original array, creating new sub-arrays for each chunk.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/arena.html#_snippet_34\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction chunkArray(array, chunkSize) { const chunks = []; for (let i = 0; i < array.length; i += chunkSize) { chunks.push(array.slice(i, i + chunkSize)); } return chunks; }\n```\n\n----------------------------------------\n\nTITLE: Start AIChat Local Server\nDESCRIPTION: This command starts the built-in HTTP server for AIChat, exposing various API endpoints and web UIs like the LLM Playground and Arena. It provides local access to chat completions, embeddings, and rerank APIs.\nSOURCE: https://github.com/sigoden/aichat/blob/main/README.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\n$ aichat --serve\nChat Completions API: http://127.0.0.1:8000/v1/chat/completions\nEmbeddings API:       http://127.0.0.1:8000/v1/embeddings\nRerank API:           http://127.0.0.1:8000/v1/rerank\nLLM Playground:       http://127.0.0.1:8000/playground\nLLM Arena:            http://127.0.0.1:8000/arena?num=2\n```\n\n----------------------------------------\n\nTITLE: Build Chat Completions Request Body\nDESCRIPTION: This function constructs the JSON request body for the chat completions API. It processes chat messages, integrates system prompts (including handling `__INPUT__` placeholders and structured prompts), sanitizes messages, and applies model settings such as `model`, `stream`, `max_output_tokens`, `temperature`, and `top_p`.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/playground.html#_snippet_25\n\nLANGUAGE: JavaScript\nCODE:\n```\nbuildBody() { let messages = []; for ([userMessage, assistantMessage] of chunkArray(this.messages, 2)) { if (assistantMessage.state === \"failed\") { continue; } else if (assistantMessage.state === \"loading\") { messages.push({ role: userMessage.role, content: userMessage.content, }); } else { messages.push({ role: userMessage.role, content: userMessage.content, }); messages.push({ role: assistantMessage.role, content: assistantMessage.content, }); } } const systemPrompt = this.settings.prompt.trim(); if (systemPrompt) { if (messages[0]?.content?.indexOf(\"__INPUT__\") > -1) { messages[0].content = systemPrompt.replace(\"__INPUT__\", messages[0].content); } else { const { system, cases } = parseStructurePrompt(systemPrompt); const promptMessages = []; if (system) { promptMessages.push({ role: \"system\", content: system, }); } for (const item of cases) { promptMessages.push({ role: \"user\", content: item.input, }); promptMessages.push({ role: \"assistant\", content: item.output, }); } messages = [...promptMessages, ...messages]; } } sanitizeMessages(messages); const body = { model: this.settings.model, messages: messages, stream: true, }; [[\"max_output_tokens\", \"max_tokens\"], [\"temperature\"], [\"top_p\"]].forEach(([setting_key, body_key]) => { if (typeof this.settings[setting_key] === \"number\") { body[body_key || setting_key] = this.settings[setting_key]; } }); const { max_output_token, require_max_tokens } = this.modelData; if (!body[\"max_tokens\"] && require_max_tokens) { body[\"max_tokens\"] = max_output_token; }; return body; },\n```\n\n----------------------------------------\n\nTITLE: Auto-Scroll Chat Body to Bottom\nDESCRIPTION: This function automatically scrolls the chat body to its bottommost position. It checks a `shouldScrollChatBodyToBottom` flag and then programmatically sets the `scrollTop` property of the chat body element, ensuring the latest messages are always visible.\nSOURCE: https://github.com/sigoden/aichat/blob/main/assets/playground.html#_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\nautoScrollChatBodyToBottom() { if (this.shouldScrollChatBodyToBottom) { let $chatBody = this.$refs[\"chat-body\"]; if (!$chatBody) { $chatBody = document.querySelector('[x-ref=\"chat-body\"]') } $chatBody.scrollTop = $chatBody.scrollHeight; } }\n```\n\n----------------------------------------\n\nTITLE: AIChat CMD Mode Input Examples\nDESCRIPTION: Examples demonstrating how to provide various types of input (direct text, stdin, local files/directories, remote URLs, external commands, combined inputs) to AIChat in CMD mode.\nSOURCE: https://github.com/sigoden/aichat/blob/main/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\naichat hello\n```\n\nLANGUAGE: Shell\nCODE:\n```\ncat data.txt | aichat\n```\n\nLANGUAGE: Shell\nCODE:\n```\naichat -f image.png -f data.txt\n```\n\nLANGUAGE: Shell\nCODE:\n```\naichat -f dir/\n```\n\nLANGUAGE: Shell\nCODE:\n```\naichat -f https://example.com\n```\n\nLANGUAGE: Shell\nCODE:\n```\naichat -f '`git diff`'\n```\n\nLANGUAGE: Shell\nCODE:\n```\naichat -f dir/ -f data.txt explain\n```"
    }
  ]
}
