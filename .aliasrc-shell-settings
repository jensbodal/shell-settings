# vi: ft=zsh

DIR="$(dirname "$(readlink -f "$0")")"

alias gdh="gd HEAD"
alias gds="gd --staged"
alias gs="git status"
alias hist="history"
alias ll="ls -la"
alias s="source ~/.zshrc && hash -r && if type direnv > /dev/null; then direnv reload; fi"
alias yarn=__yarn

# functions
alias bunx=__bunx
alias mise-install=__mise-install
alias mise-update=__mise-update
alias cdf=__cdf
alias cdt=__cdt
alias dns=__dns
alias ff=__ff
alias fif=__fif
alias git-set-origin=__git-set-origin
alias git-vim-status=__git-vim-status
alias screen=__screen
alias ssh-keygen-secure=__ssh-keygen-secure
alias u=__u
alias usingport=__usingport

# bash scripts
export BASH_SCRIPTS_PATH="$DIR/scripts"
export PATH="$BASH_SCRIPTS_PATH:$PATH"

# bash script aliases
alias htop="$BASH_SCRIPTS_PATH/alias_htop"
alias ncdu="$BASH_SCRIPTS_PATH/alias_ncdu"
alias nnn="$BASH_SCRIPTS_PATH/alias_nnn"
alias disknnn="nnn"

# node scripts
__add_node_scripts_to_path() {
  local nodedir="$DIR/scripts/node"
  for f in `ls $nodedir`; do
    local filename=$(basename "$nodedir/$f" .mjs)
    alias $filename="$nodedir/$f"
  done
}
__add_node_scripts_to_path

################################################################
# aliasing these to functions breaks functionality
cd() {
  if [ $# -eq 1 -a -f "$@" ]; then
    echo "file found, changing to parent directory"
    cdf "$1"
    return $?
  fi

  if [ "$1" != "-" -a ! -d "$@" ]; then
    echo "no such directory: $@"
    return 1
  fi

  builtin cd "$@" && echo "$OLDPWD --> $PWD"
}

__rmrf() {
  SECONDS=0
  echo "rm -rf $@"
  local volume="$(df -P . | sed -n '$s/[^%]*%[[:blank:]]*//p')"
  local tmp=$(mktemp)
  local tmpFolder=$(basename $tmp)
  local folders=("$@")

  if [ $volume = "/" ]; then
    local trash="/tmp/trash"
  else
    local trash="$volume/tmp/trash"
  fi

  mkdir -p $trash

  if [ "$#" -eq 0 ]; then
    echo "trash: $trash"
    ls -la $trash
    return 0;
  fi

  local trashfolder="$trash/$tmpFolder"
  mkdir -p $trashfolder

  echo "moving "$folders" to $trashfolder"
  mv $folders $trashfolder
  echo "emptying $trash in the background..."

  __rmrfhelper() {
    duration=$SECONDS
    command rm -rf $trash
    echo "$(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed."
  }

  { __rmrfhelper & } 2>/dev/null
}

rm() {
  if [ "$1" = "-rf" ]; then
    shift
    __rmrf "$@"
    return $?
  fi

  command rm "$@"
}
################################################################

__bunx() {
  if exists bun; then
    bun x "$@"
  else
    mise-install bun && bun x "$@"
  fi
}

__mise-install() {
  if [ -z $1 ]; then
    echo "missing plugin name"
    return
  fi

  mise plugin add "$1"
  mise install "$1@latest"
  mise global "$1@latest"
}

__mise-update() {
  mise update
  for tool in $(mise plugin list); do
    mise install "${tool}" latest  \
      &&  mise global "${tool}" latest  \
      &&  echo "${tool} set globally"
    done
}

__caff() {
  if command -v caffeinate &> /dev/null
  then
    caffeinate -disu
  else
    echo "caffeinate not supported"
  fi
}

__cdf() {
  cd "$(dirname "$1")"
}


# cd to file or folder
__cdt() {
  while [[ $PWD != '/' && `basename $PWD` != "$1" && ! -f "$1" ]]; do cd ..; done
}

__dns() {
  domain="$1"
  echo "[nameservers]"
  dig +short "$domain" ns
  echo "[a records]"
  dig +short "$domain" a
  echo "[cname records]"
  dig +short "$domain" cname
  echo "[txt records]"
  dig +short "$domain" txt
  echo "[mx records]"
  dig +short "$domain" mx
  echo "[aaaa records]"
  dig +short "$domain" aaaa
  echo "[srv records]"
  dig +short "$domain" srv
}

# find file
__ff() {
  local needle="${1:- }"
  local grepopts="$2"

  find . -iname "*$needle*" -type f | grep "$needle" $grepopts
}

# find in file
__fif() {
  grep "$@" -r . | grep "$@"
}

__git-set-origin() {
  local remote="${1:-origin}"
  local currentbranch=$(git rev-parse --abbrev-ref HEAD)

  local gitpath="$remote/$currentbranch"
  echo "Setting upstream to \"$gitpath\""
  git branch --set-upstream-to="$gitpath"
}

__git-vim-status() {
  vim -p $(git status -s | sed -r 's#^(.*->)?[ARMU? ]+(.*)$#\2#')
}

__screen() {
  if [[ ! $1 =~ ^- ]]; then
    if [[ $1 == "ls" ]]; then
      command screen -ls
      return $?
    fi

    command screen -RR -S "$1"
    return $?
  fi

  command screen "$@"
  return $?
}

__ssh-keygen-secure() {
  ssh-keygen -t ed25519 -a 100
}

__u() {
  if exists brew; then
    echo "updating brew"
    brew update && brew upgrade
  fi
  if exists pacman; then
    echo "updating pacman"
    sudo pacman -Syu
  fi
  if exists apt; then
    if apt -v &> /dev/null; then
      echo "updating apt"
      sudo apt update && sudo apt upgrade
    fi
  fi
  if exists yum; then
    echo "updating yum"
    sudo yum update
  fi
}

__usingport() {
  ports=`echo "$@" | egrep -o "\d+" | xargs`
  dokill=`echo "$@" | egrep -o "\-k"`
  len=0

  results=`lsof $(echo $ports | sed -E 's#([0-9]+)#-i :\1#g') -n -P`

  if [ ! -z $results ]; then
    echo "\n$results\n"
  else
    echo "[usingport] No processes found using ports [$ports]"
    return 1
  fi

  pids=`echo $results | sed '1D' | awk '{print $2}' ORS=' '`

  if [ ! -z $dokill ]; then
    echo "killing pids [$(echo $pids | xargs)]"
    echo $pids | xargs kill -9
  else
    if [ $len -gt 0 ]; then
      echo "\n[usingport] pass -k to kill all matching processes"
    fi
  fi
}

__yarn() {
  echo "!!! use bun !!!"
  return 1
}
